[[{"l":"Welcome to my Personal Site"}],[{"l":"Connecting wallet address to user","p":["The user needs to send an mail to connect their wallet address with themselves. The email address should be a Sabanci University address, the subject section should only include the word “address” and the body of the mail should only have the waller address. An example mail can be seen below. wallet address mail"]}],[{"l":"Developer Documentation"},{"i":"how-to-install-and-run-the-front-end","l":"How to install and run the front-end:","p":["Download and install node.js node.js reference link: https://nodejs.org/en/download/","Download and install npm or yarn, you need to install npm to download yarn yarn reference link: https://classic.yarnpkg.com/lang/en/docs/install/#windows-stable npm reference link: https://docs.npmjs.com/downloading-and-installing-node-js-and-npm","Install the dependency packages in the project folder navigate to directory using","install the dependencies using \"npm install\" or \"yarn install\" install next if needed using \"npm install next\" or \"yarn install next\" Clone the repo from: https://github.com/Cem-Kaya/SU_Govern","To run the front-end: in the project folder change the directory using","run the front end using \"npm run dev\" or \"yarn dev\"","Deploying Contracts on TestNet: Remix IDE was used for this. Contracts are compiled in this order: 1) token.sol, 2) creator.sol, 3) newDAO1.sol 4) newFactory1.sol. Contracts are deployed in this order: 1) creator.sol, 2) newFactory1.sol. While deploying newFactory1.sol use the address of creator.sol.","Connecting to Front End: The files that needs modification are found in the directory below.","In dao.js and index.js, the address of daoFactory should be typed in the statement where the daoFactoryContract is defined. In dao.js, line 114, and in index.js, line 180. In addition to this, in order to get YK privileges, the first admin of the Top DAO needs to withdraw 1 YK token from TOP DAO. This can be done through the frontend. This is a one time case during creation. The first contract needs to be deployed using Remix IDE."]},{"l":"Contracts"},{"i":"creatorsol","l":"Creator.sol","p":["The below Solidity contract is named creator and it implements the icreator interface. The purpose of this contract is to create two tokens and transfer ownership of those tokens to the factory contract.","The createToken function is the main function of this contract. It takes four parameters: yk_token_name, yk_token_symbol, voter_token_name, and voter_token_symbol. These parameters represent the names and symbols of the two tokens to be created.","Inside the function, the address of the factory contract is obtained from the msg.sender variable. Two instances of the SUToken contract are created, representing the two tokens. The SUToken contract is assumed to be defined in the token.sol file.","After the tokens are created, the ownership of each token is transferred to the factory contract using the transferOwnership function of the SUToken contract.","Finally, the addresses of the created tokens are returned as a tuple.","Please note that some parts of the contract are commented out, such as the import statement for DAO.sol. It appears that those parts are not relevant to the current functionality of the contract.","Remember to customize and adapt this documentation according to your specific needs, such as providing more details about the purpose and usage of the contract or explaining any additional functions or dependencies."]},{"i":"migrationssol","l":"Migrations.sol","p":["The Migrations contract is a simple contract that stores the last completed migration. The contract has a setCompleted function that sets the last_completed_migration variable to the value passed in as a parameter. However, this function can only be called by the contract owner.","The restricted modifier restricts the function so that only the owner of the contract can call it. If a non-owner account attempts to call the function, an exception is thrown and the transaction is reverted.","The contract also has an owner variable that is initialized with the address of the contract deployer. This address is used in the restricted modifier to check that the calling account is the owner of the contract.","This contract can be used as a base contract for contract migrations."]},{"i":"newdao1sol","l":"newDAO1.sol","p":["_dao_description: A string representing the description of the DAO.","_dao_id: An integer representing the ID of the DAO.","_dao_name: A string representing the name of the DAO.","_factory: An instance of the DAOFactory contract representing the DAO factory used to create the DAO.","_imageUrl: A string representing the URL of the DAO's image.","A brief description of each function:","accept_proposal: This external function accepts a proposal by changing its status to Status.Accepted. The function takes in a parameter _ proposalId, which specifies the ID of the proposal to be accepted.","CREATE_PROPOSAL_MIN_SHARE: A constant that sets the minimum number of shares required to create a proposal.","createProposal: This function creates a new proposal. It takes in six parameters: name, which is the name of the proposal; description, which is the description of the proposal; _options, which is an array of vote options; _options_num, which is an array of corresponding vote option numbers; _power, which is the maximum vote power for the proposal; and _type, which is the type of the proposal (0 for normal, 1 for weighted). It requires the caller to have YK privileges and creates a new proposal with the specified parameters. It also updates the proposal count.","first_yk: The address of the initial YK token holder.","In the constructor, the factory, dao_name, dao_id, dao_description, yk_token, voter_token, and imageUrl variables are set to their corresponding parameter values. The yk_shares_to_be_given and voter_shares_to_be_give n mappings are then initialized with a share value of 1 * 10 ** 18 for the initial YK token holder.","iterate_proposals: This public function iterates through all proposals and emits proposal information for each proposal. It updates the active voter lock if the proposal's status is not pending. The function does not take in any parameters.","mint_from_DAO_voter_token: This internal function allows the DAO contract to mint voter tokens. The function takes in a parameter _ amount, which specifies the amount of voter tokens to be minted.","mint_from_DAO_yk_token: This internal function allows the DAO contract to mint YK tokens. The function takes in a parameter _ amount, which specifies the amount of YK tokens to be minted.","nextProposalId: An integer that tracks the ID for the next proposal to be created.","Note that the code uses some external functions, such as stringsEquals, which is a custom implementation of string comparison, and voter_token.balanceOf, which retrieves the balance of a voter's tokens.","pending_proposal: This external function sets a proposal's status to Status.Pending. The function takes in a parameter _ proposalId, which specifies the ID of the proposal to be set as pending.","proposals: A mapping of proposal IDs to Proposal objects. This is used to store all the proposals created by the contract.","reject_proposal: This external function rejects a proposal by changing its status to Status.Rejected. The function takes in a parameter _ proposalId, which specifies the ID of the proposal to be rejected.","retrieve_proposal_names: This function simply retrieves the names of all proposals. It returns an array of proposal names.","send_voter_tokens_to_address_yk_directly: This function sends voter tokens directly to a specified address from the DAO. It takes in two parameters: voter_candidate, which is the address to send the voter tokens to, and _amount, which is the amount of voter tokens to send. It requires the caller to have YK privileges and updates the amount of voter tokens that will be given to the specified address. In addition to this, it also mints voter tokens from the DAO.","send_voter_tokens_to_address_yk: This function sends voter tokens to a specified address. It takes in two parameters: voter_candidate, which is the address to send the voter tokens to, and _amount, which is the amount of voter tokens to send. It requires the caller to have YK privileges and updates the amount of voter tokens that will be given to the specified address.","send_yk_tokens_to_address_yk_directly: This function sends YK tokens directly to a specified address from the DAO. It takes in two parameters: yk_candidate, which is the address to send the YK tokens to, and _amount, which is the amount of YK tokens to send. It requires the caller to have YK privileges and updates the amount of YK tokens that will be given to the specified address. In addition to this, it also mints YK tokens from the DAO.","send_yk_tokens_to_address_yk: This function sends YK tokens to a specified address. It takes in two parameters: yk_candidate, which is the address to send the YK tokens to, and _amount, which is the amount of YK tokens to send. It requires the caller to have YK privileges and updates the amount of YK tokens that will be given to the specified address.","The code uses several Solidity concepts, such as function modifiers ( require statements) and structs ( Proposal), to ensure that the functions are secure and perform as intended.","The constructor function initializes the DAO contract with the following parameters:","The contract contains several mappings and constants used for tracking and storing data. These include:","The MyDAO contract implements a decentralized autonomous organization (DAO) that allows members to create proposals and vote on them. It defines a Proposal struct that contains information about each proposal, including its unique identifier, author, name, description, creation timestamp, options, status, power, and proposal information type. The contract also includes a private function stringsEquals that compares two strings and returns a boolean indicating whether they are equal. The public variables of the contract include the name, description, debugging information, image URL, and unique identifier of the DAO. It also defines two enums for voting options and proposal status. The contract imports the itoken.sol and newFactory1.sol contracts and declares a DAOFactory variable for the newFactory1 contract. The contract is responsible for creating and managing proposals, and tracking voting shares and tokens for voters and YK token holders.","token_amount_to_be_refunded: A mapping of voter addresses to proposal IDs to refund amounts. This is used to store the amount of tokens to be refunded for a voter.","tokens_not_refunded: A mapping of voter addresses to proposal IDs to boolean values. This is used to track whether tokens have been refunded for a proposal to prevent multiple refunds.","transferLock: A mapping of addresses to boolean values that tracks the transfer lock status for addresses.","vote_power_weighted: This function is similar to vote_power, but it includes an additional argument weight, which is a uint representing the weight to apply to the vote powers. The weight is used to determine the influence of each voter's shares on the proposal. The function first checks if the voter has already voted, if they have enough shares to vote on the proposal (with the option to change the weight), and if the voting period is still open. If all conditions are met, the function calculates the total power of the votes, checks that the total power does not exceed the proposal power, and then adds the vote powers (multiplied by the weight) to the corresponding proposal options. Finally, it updates the voter's vote status and active voter lock for the proposal.","vote_power: This function performs a weighted vote on a proposal. It takes three arguments: _proposalId(an unsigned integer representing the ID of the proposal), _vote(a string array representing the vote options), and _power(an unsigned integer array representing the corresponding vote powers). The function first checks if the voter has already voted, if they have enough shares to vote on the proposal, and if the voting period is still open. If all conditions are met, the function calculates the total power of the votes, checks that the total power does not exceed the proposal power, and then adds the vote powers to the corresponding proposal options. Finally, it updates the voter's vote status and active voter lock for the proposal.","vote: This function performs a non-weighted vote on a proposal. It takes in three parameters: _proposalId, which is the ID of the proposal; _vote, which is an array of vote options; and _power, which is an array of corresponding vote powers. It requires the caller to have voter privileges and updates the vote count for the specified proposal.","voter_shares_to_be_given: A mapping of voter addresses to voter share amounts. This is used to track the number of voter shares to be given to a voter.","voter_token_in: An instance of the ISUToken contract representing the voter token used by the DAO.","voter_token: An instance of the ISUToken contract. This is the contract for the voter token used by the DAO.","votes: A mapping of voter addresses to proposal IDs to boolean values. This is used to track which addresses have already voted for a given proposal to prevent double voting.","VOTING_PERIOD: A constant that sets the duration of the voting period for proposals.","withdraw_voter_tokens: This external function allows a user to withdraw voter tokens from the DAO. The function takes in a parameter _ amount, which specifies the amount of voter tokens to be withdrawn. The function checks whether the user has enough shares and transfers the specified amount of voter tokens from the DAO to the user. It also mints voter tokens for the DAO.","withdraw_yk_tokens: This external function allows a user to withdraw YK tokens from the DAO. The function takes in a parameter _ amount, which specifies the amount of YK tokens to be withdrawn. The function checks whether the user has enough shares and transfers the specified amount of YK tokens from the DAO to the user. It also mints YK tokens for the DAO.","yk_shares_to_be_given: A mapping of YK token holder addresses to YK share amounts. This is used to track the number of YK shares to be given to a YK token holder.","yk_token_in: An instance of the ISUToken contract representing the YK token used by the DAO.","yk_token: An instance of the ISUToken contract. This is the contract for the YK token used by the DAO."]},{"i":"newfactory1sol","l":"newFactory1.sol","p":["This file contains the DAOFactory contract. This contract creates the Top DAO, which is the DAO that supervises all of it’s sub-DAO’s and mints 1000 tokens to this factory. This function also inludes the creation and assignment of the YK tokens to the factory.","The below function is used to create a childDAO under the Top DAO. It also checks if the requesting user has a YK token.","The below function is used to mint YK tokens for a DAO.","The below function is used to give creator privileges.","The below function is used to get the address of the parent DAO of a child DAO.","The below function is used to get the address of the current DAO.","The below function is used to delete a DAO. The function checks if the request is sent by a YK member and if so continues with deletion and if not throws an error message. The function also checks if the DAO to be deleted has any child DAOs and if they exist deletes them as well."]},{"i":"tokensol","l":"Token.sol","p":["The below function is used for transfer processes. The function checks the balance of the owner to make sure there are enough credits and gives an option to have a debt if balance is insufficient and modifies the balance amount accordingly.","The below function allows the user to take back all of the delegated tokens."]},{"l":"Adding an Image to a DAO","p":["The constructor of newdao1.sol file includes an imageurl variable. During the creation of a dao a line like the following can be used to pass the link address of an image to be used for the DAO."]}],[{"l":"Setting up metamask","p":["First, visit the MetaMask website at metamask.io.","Click the \"Get Chrome Extension\" button, or \"Get Firefox Extension\" if you use Firefox.","Follow the instructions for adding the extension to your browser.","Once installed, click the MetaMask icon in your browser to launch it.","You'll be prompted to create a new account or import an existing one. Follow the prompts to create your account.","Set a strong password and backup your seed phrase. This phrase is important because it's the only way to recover your account if you lose your password or if your computer crashes.","You'll also be asked to confirm that you've backed up your seed phrase by entering it in the correct order.","Finally, you're all set! You can now use MetaMask to interact with Ethereum-based dApps and store your ETH and ERC-20 tokens securely, but you will need to change to MATIC network to interact with SUGovern."]}],[{"i":"what-is-sugovern","l":"What is SUGovern?","p":["SUGovern is a decentralized voting platform to be used by university clubs."]},{"l":"Decentralized","p":["SUGovern is used to create DAOs or Decentralized Autonomous Organizations. SUGovern uses a blockchain network for transparency and security."]}]]